{"title":"Exploratory Data Analysis (EDA)","markdown":{"yaml":{"title":"Exploratory Data Analysis (EDA)","format":{"html":{"code-fold":true,"toc":true,"number-sections":true,"df-print":"paged"}}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\nExploratory Data Analysis (EDA) is one of the fundamental steps in any data science process. It allows us to **understand the structure**, **detect anomalies**, and **uncover patterns** in the data before modeling.\n\n> *\"Without EDA, you're not doing data science, you're just guessing.\"*\n\nEDA combines statistics, programming, and **visualization** to explore datasets. This report is designed to help you practice these core skills using real-world data.\n\n\n## Dataset\n\nWe will use the **`movies`** dataset from [vega-datasets](https://vega.github.io/vega-datasets/), which includes information about thousands of films such as their ratings, genres, duration, and box office revenue.\n\nLet's load and preview the dataset:\n\n```{python}\nimport pandas as pd\nimport altair as alt\nfrom vega_datasets import data\n\n# Load dataset\nmovies = data.movies()\n\n# Show first rows\nmovies.head()\n```\n\nNow, let’s examine the shape (number of rows and columns) of the dataset:\n\n```{python}\nmovies.shape\n```\n\nThis tells us how many entries (rows) and features (columns) are present in the dataset.\n\n\n## First Steps\n\nBefore diving deeper into the data, it’s useful to explore some key metadata:\n\n- ✅ The **column names** and their **data types**\n- ⚠️ The **presence of missing values**\n- 📊 Summary **statistics** for numeric columns\n\n### Column Names and Data Types\n\nUnderstanding the structure of the dataset helps us know what type of data we're dealing with.\n\n```{python}\nmovies.dtypes\n```\nWe can also use .info() for a more complete summary, including non-null counts:\n\n\n```{python}\n# Overview of the dataset\nmovies.info()\n```\n\n## Missing Values\n\nDetecting and handling missing values is a critical step in any EDA process. Missing data can bias analysis or break downstream models if not handled properly.\n\n- Detect **patterns** in missingness\n- Identify if some columns are almost entirely null\n- Decide whether to **drop** or **impute** certain variables\n\n\n### Percentage of Missing Values per Column\n\nLet’s start by computing the percentage of missing values in each column:\n\n```{python}\nnan_percent = movies.isna().mean() * 100\nnan_percent_sorted = nan_percent.sort_values(ascending=False).round(2)\nnan_percent_sorted\n```\n\n### Reshaping the Data for Visualization\n\nTo visualize missing values with Altair, we need to reshape the data into a long format where each missing value is a row:\n\n```{python}\nmovies_nans = movies.isna().reset_index().melt(\n    id_vars='index',\n    var_name='column',\n    value_name=\"NaN\"\n)\nmovies_nans\n```\n\n### Heatmap of Missing Data\n\nThis heatmap shows where missing values occur across rows and columns. Patterns may indicate:\n\n- Columns with consistently missing values\n- Entire rows with large gaps\n- Correlated missingness between variables\n\nTo avoid limitations in the number of rows rendered by Altair, we disable the max rows warning:\n\n```{python}\nalt.data_transformers.disable_max_rows()\n```\n\nNow we can create the heatmap:\n```{python}\nalt.Chart(movies_nans).mark_rect().encode(\n    alt.X('index:O'),\n    alt.Y('column'),\n    alt.Color('NaN')\n).properties(\n    width=1000\n)\n```\nThis plot can help identify columns or rows with critical data issues.\n\n### Dropping Columns with High Missing Rate\n\nIn many real-world cases, we may decide to remove columns that have too many missing values. Let’s set a threshold of 70%:\n\n```{python}\nthreshold_nan = 70 # in percent\ncols_to_drop = nan_percent[nan_percent>threshold_nan].index\ncols_to_drop\n```\nThese columns have more than 70% missing values and may not be useful for analysis.\n\n\n## Cleaned Dataset\nFinally, we drop the selected columns and inspect the updated dataset:\n\n```{python}\nmovies_cleaned = movies.drop(columns=cols_to_drop)\nmovies_cleaned\n```\n\n\n\n\n# Types of Data Analysis in EDA\n\nUnderstanding the nature of variables and the relationships between them is central to Exploratory Data Analysis (EDA). Depending on the number and type of variables involved, we can classify analysis into three main categories: univariate, bivariate, and multivariate.\n\n@tbl-analysis-types shows how EDA analysis types vary depending on the number and types of variables involved.\n\n> This classification helps guide the selection of appropriate visualization techniques and statistical methods for each case.\n\n::: {.table-caption}\n| **Analysis Type** | **Variable Types**             | **Description**                              | **Examples**                        |\n|-------------------|--------------------------------|----------------------------------------------|-------------------------------------|\n| Univariate        | Categorical                    | One qualitative variable                     | Gender, Product Category            |\n| Univariate        | Quantitative                   | One numerical variable                       | Income, Age, Runtime                |\n| Bivariate         | Categorical – Categorical      | Two qualitative variables                    | Gender vs Nationality               |\n| Bivariate         | Categorical – Quantitative     | One qualitative and one numerical            | Province vs Population              |\n| Bivariate         | Quantitative – Quantitative    | Two numerical variables                      | Age vs Income                       |\n| Multivariate      | 3 or more variables (any mix)  | Combination of categorical and/or numerical  | Age vs Income by Gender, etc.       |\n\nTable: **Types of analysis and variable combinations used in EDA** {#tbl-analysis-types}\n:::\n\n## Univariate Analysis: Quantitative\n\nA univariate analysis focuses on examining a single numeric variable to understand its distribution, shape, central tendency, and spread. One of the most common tools for this is the **histogram**.\n\nIn this case, we’ll explore the distribution of the movie runtime (`Running_Time_min`).\n\n### Basic Histogram\n\nWe start by creating a histogram to visualize the distribution of running times:\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('Running_Time_min',bin=alt.Bin(maxbins=30)),\n    alt.Y('count()')\n).properties(\n    title='Histogram of Movie Runtimes (30 bins)'\n)\n```\nThis chart shows how many movies fall into each time interval (bin). However, histograms can look quite different depending on the number and size of bins used.\n\n### Effect of Bin Size\n\nLet’s compare how the histogram shape changes with different bin sizes:\n```{python}\nhistogram_1 = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('Running_Time_min',bin=alt.Bin(maxbins=8)),\n    alt.Y('count()')\n)\n\nhistogram_2 = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('Running_Time_min',bin=alt.Bin(maxbins=10)),\n    alt.Y('count()')\n)\n\nhistogram_1 | histogram_2\n\n```\n\nEven though both plots use the same data, the choice of bin size changes the visual interpretation. A small number of bins may hide details, while too many bins can make it harder to spot trends.\n\n\n### Density plots, or Kernel Density Estimate (KDE)\n\nDensity plots offer a smoothed alternative to histograms. Instead of using rectangular bins to count data points, they estimate the probability density function by placing bell-shaped curves (kernels) at each observation and summing them.\n\nThis approach helps reduce the visual noise and jaggedness that can occur in histograms and gives a clearer picture of the underlying distribution.\n\n```{python}\nalt.Chart(movies_cleaned).transform_density(\n    'Running_Time_min',\n    as_=['Running_Time_min','density'],\n).mark_area().encode(\n    alt.X('Running_Time_min'),\n    alt.Y('density:Q')\n).properties(\n    title=\"Movies runtime\"\n)\n```\n\n### Grouped Density plot\n\nWe can also compare distributions across groups by splitting the KDE by a **categorical variable** using the groupby parameter. This helps us see how the distribution differs between categories, such as genres.\n\n```{python}\nselection = alt.selection_point(fields=['Major_Genre'], bind='legend')\n\nalt.Chart(movies_cleaned).transform_density(\n    'Running_Time_min',\n    groupby=['Major_Genre'],\n    as_=['Running_Time_min', 'density'],\n).mark_area(opacity=0.5).encode(\n    alt.X('Running_Time_min'),\n    alt.Y('density:Q', stack=None),\n    alt.Color('Major_Genre'),\n    opacity=alt.condition(selection, \n        alt.value(1), \n        alt.value(0.05)\n    )\n).add_params(\n    selection\n).properties(\n    title=\"Movies Runtime by Genre (Interactive Filter)\"\n).interactive()\n```\n\nThe **transparency (opacity=0.5)** allows us to observe overlapping distributions and ensures that small density areas are not completely hidden behind larger ones.\n\nFrom this plot, we can observe, for example, that *Drama* movies have runtimes nearly as long as the longest *Adventure* movies, even though their overall distributions differ.\n\n## Bivariate Analysis: Categorical vs Quantitative\n\nBivariate analysis examines the relationship between two variables. In this case, we focus on one categorical variable (e.g., genre) and one quantitative variable (e.g., revenue), which is a very common scenario in exploratory data analysis.\n\nThis type of analysis is useful to:\n- Compare average or median values across categories.\n- Detect outliers or high-variance groups.\n- Understand distributional differences across categories.\n\nBelow are several effective visualizations for this analysis.\n\n### Basic Barchart\n\nBar charts are effective for comparing aggregated values (like the mean) across different groups. However, they hide the distribution and variation within each group.\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('mean(Worldwide_Gross)'),\n    alt.Y(\"Major_Genre\")\n).properties(\n    title=\"Average Worldwide Gross by Genre\"\n)\n```\nThis bar chart shows the mean Worldwide Gross per genre. It is useful for identifying which genres are more profitable on average, but does not show how spread out the data is.\n\n### Tick Plot\n\nTo visualize individual data points, we use a tick plot. This helps uncover variability within genres and detect outliers.\n\n```{python}\nalt.Chart(movies_cleaned).mark_tick().encode(\n    alt.X('Worldwide_Gross'),\n    alt.Y(\"Major_Genre\"),\n    alt.Tooltip('Title:N')\n).properties(\n    title=\"Individual Gross per Movie by Genre\"\n)\n```\n\n### Heatmaps\n\nHeatmaps can summarize the frequency of data points across both axes (quantitative and categorical) using color intensity. It’s particularly useful for spotting patterns without getting overwhelmed by individual points.\n\n```{python}\nalt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X('Worldwide_Gross',bin=alt.Bin(maxbins=100)),\n    alt.Y(\"Major_Genre\"),\n    alt.Color('count()'),\n    alt.Tooltip('count()')\n).properties(\n    title=\"Heatmap of Movie Counts by Gross and Genre\"\n)\n```\nThis heatmap shows how frequently movies from each genre fall into different revenue ranges.\n\n\n\n### Boxplot\n\nBoxplots are useful for comparing distributions across categories and identifying outliers. Boxplots summarize a distribution using five statistics:\n\n- Median (Q2)\n- First Quartile (Q1)\n- Third Quartile (Q3)\n- Lower Whisker (Q1 - 1.5 × IQR)\n- Upper Whisker (Q3 + 1.5 × IQR)\n\n```{python}\nalt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X('Worldwide_Gross'),\n    alt.Y(\"Major_Genre\")\n).properties(\n    title=\"Boxplot of Worldwide Gross by Genre\"\n)\n```\n\n\n### Side-by-side: Boxplot and Bar Chart\n\nTo contrast aggregated values (bar chart) with the full distribution (boxplot), we can display them together:\n\n```{python}\nbar = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('mean(Worldwide_Gross)'),\n    alt.Y(\"Major_Genre\")\n)\n\nbox = alt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X('mean(Worldwide_Gross)'),\n    alt.Y(\"Major_Genre\")\n)\n\nbox | bar\n```\nThis comparison reveals whether the mean is a good representative of the genre, or whether the data is skewed or contains outliers that affect the average\n\n## Bivariate Analysis: Quantitative vs Quantitative\n\nWhen analyzing two quantitative (numerical) variables simultaneously, we aim to discover possible relationships, trends, or correlations. This type of bivariate analysis can reveal whether increases in one variable are associated with increases or decreases in another (positive or negative correlation), or if there’s no relationship at all. The most common and intuitive visualization for this is the **scatterplot**.\n\n### Scatterplots\n\nScatter plots are effective visualizations for exploring **two-dimensional distributions**, allowing us to identify patterns, trends, clusters, or outliers.\n\nLet’s start by visualizing how movies are rated across two popular online platforms:\n\n- [IMDb](https://www.imdb.com/)  \n- [Rotten Tomatoes](https://www.rottentomatoes.com)\n\nAre movies rated similarly on different platforms?\n\n\n```{python}\nalt.Chart(movies_cleaned).mark_point().encode(\n    alt.X('IMDB_Rating'),\n    alt.Y('Rotten_Tomatoes_Rating')\n).properties(\n    title=\"IMDB vs Rotten Tomatoes Ratings\"\n)\n```\n\n### Scatterplot Saturation\n\nScatterplots can become saturated when too many points overlap in a small area of the chart, making it difficult to distinguish dense regions from sparse ones. For example, when plotting financial variables like production budget versus worldwide gross:\n\n\n```{python}\nsaturated = alt.Chart(movies_cleaned).mark_point().encode(\n    alt.X('Production_Budget'),\n    alt.Y('Worldwide_Gross')\n).properties(\n    title=\"Saturated Scatterplot: Budget vs Gross\"\n)\nsaturated\n```\n\n### Using Binned Heatmap to Reduce Saturation\nTo address saturation, we can **bin** both variables and use a heatmap where the color intensity represents the number of movies that fall into each rectangular region of the grid. This makes dense areas more interpretable\n\n```{python}\nheatmap_scatter = alt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X('Production_Budget', bin=alt.Bin(maxbins=60)),\n    alt.Y('Worldwide_Gross', bin=alt.Bin(maxbins=60)),\n    alt.Color('count()'),\n    alt.Tooltip('count()')\n).properties(\n    title=\"Binned Heatmap: Budget vs Gross\"\n)\nheatmap_scatter\n```\n\n### Side-by-side Comparison\n\nCompare the raw scatterplot with the heatmap representation:\n\n\n```{python}\nsaturated | heatmap_scatter\n```\n\n\n## Bivariate Analysis: Categorical vs Categorical\n\n\nWhen working with **two categorical variables**, bivariate analysis helps us understand how categories from one variable relate or are distributed across the other. For example, we might want to know how different **movie genres** are rated according to the **MPAA rating system**. Visualization techniques like grouped bar charts and faceted plots can reveal patterns, associations, or class imbalances.\n\n### Basic Faceted Bar Chart\n\nWe begin by exploring how movies are rated (MPAA_Rating) across different genres (Major_Genre). A faceted bar chart allows us to visualize this relationship by plotting a bar chart **per genre**, helping to identify genre-specific rating distributions.\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre'\n)\n```\n\n### Vertical Faceting for Alignment\n\nFaceting horizontally can make comparisons across genres harder when the x-axis is misaligned. By specifying columns=1, we lay out the facets vertically, making it easier to compare counts across genres.\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre',\n    columns=1\n)\n```\n\n### Dependent vs Independent Axis Scaling\n\nBy default, facet plots share the same x-axis scale (dependent scale), which allows for easier comparison across panels. However, when the number of observations varies greatly between genres, this shared scale can compress some charts.\n\nWe can instead use independent x-axis scaling for each facet. This highlights the relative distribution within each genre.\n\n```{python}\nshared_scale = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre',\n    columns=4\n)\n\nindependent_scale = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre',\n    columns=4\n).resolve_scale(x='independent')\n\nshared_scale | independent_scale\n```\n\nThe left panel (shared scale) makes absolute comparisons between genres, while the right panel (independent scale) makes within-genre comparisons more readable.\n\n\n### Heatmaps\n\nHeatmaps are effective for visualizing the relationship between two **categorical variables** when the goal is to display **counts or frequency** of occurrences. They map **the number of observations** to **color**, providing an intuitive view of which category pairs are most or least common.\n\nWe can enhance this basic representation by also using **marker size**, combining both **color intensity** and **circle area** to represent counts more effectively. This dual encoding can improve interpretation, especially when printed in grayscale or when there are subtle color differences.\n\n\n\n```{python}\nheatmap_color = alt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X('MPAA_Rating'),\n    alt.Y('Major_Genre', sort='color'),\n    alt.Color('count()')\n).properties(\n    title=\"Heatmap with Color (Count of Movies)\"\n)\n\nheatmap_size = alt.Chart(movies_cleaned).mark_circle().encode(\n    alt.X('MPAA_Rating'),\n    alt.Y('Major_Genre', sort='color'),\n    alt.Color('count()'),\n    alt.Size('count()')\n).properties(\n    title=\"Heatmap with Color + Size (Count of Movies)\"\n)\n\nheatmap_color | heatmap_size\n```\n\n\n## Multivariate Analysis\n\n\nMultivariate analysis helps us understand the interactions and relationships among multiple variables simultaneously. In the context of numerical features, it is useful to explore pairwise distributions, correlations, and detect potential clusters or anomalies.\n\nWhen the number of variables is large, **repeated charts** such as histograms or scatter plot matrices help us summarize patterns efficiently and consistently across all numerical dimensions.\n\n### Repeated Histograms for Numerical Columns\n\nWe first identify and isolate all numerical columns from the dataset. Then we repeat a histogram for each of these columns to understand the individual distributions. This overview is helpful to detect skewness, outliers, or binning decisions that affect how data is grouped visually.\n\n\n```{python}\n# Select only numerical columns\nnumerical_columns = movies_cleaned.select_dtypes('number').columns.tolist()\n```\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X(alt.repeat(),type='quantitative',bin=alt.Bin(maxbins=30)),\n    alt.Y('count()')\n).properties(\n    width=150,\n    height=150\n).repeat(\n    numerical_columns,\n    columns=4\n)\n\n```\n\n### Scatter Plot Matrix (Pairplot)\n\nA scatter plot matrix shows the pairwise relationships between all numerical variables. This is a common exploratory tool to detect:\n\n- Correlations between variables\n- Outliers or clusters\n- Relationships useful for prediction models (e.g., to predict rating or budget)\n\nWe focus especially on the plots below the diagonal, as they are not duplicated.\n```{python}\nalt.Chart(movies_cleaned).mark_point().encode(\n    alt.X(alt.repeat('column'),type='quantitative'),\n    alt.Y(alt.repeat('row'),type='quantitative'),\n    alt.Tooltip('Title:N')\n).properties(\n    width=100,\n    height=100\n).repeat(\n    column=numerical_columns,\n    row=numerical_columns\n)\n```\n\n### Heatmap Matrix\nWhen scatter plots become too saturated (many overlapping points), heatmaps offer a better alternative by binning the numeric values and encoding the **count** in **color intensity**.\n\n```{python}\nalt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X(alt.repeat('column'),type='quantitative',bin=alt.Bin(maxbins=30)),\n    alt.Y(alt.repeat('row'),type='quantitative',bin=alt.Bin(maxbins=30)),\n    alt.Color('count()'),\n    alt.Tooltip('count()')\n).properties(\n    width=100,\n    height=100\n).repeat(\n    column=numerical_columns,\n    row=numerical_columns\n).resolve_scale(\n    color='independent'\n)\n```\n\nTo gain deeper insights into the dataset, it's important to analyze how **numerical variables** behave across **different categories**. This type of multivariate analysis allows us to:\n\n- Compare distributions across categories\n- Detect outliers within categories\n- Observe central tendency (median, quartiles) and spread (range, IQR)\n\nBoxplots are particularly effective for this purpose. In the following visualizations, we explore these relationships by **repeating plots across combinations** of categorical and numerical features.\n\n### Filter Categorical Columns\n\nFirst, we select the relevant categorical columns, excluding identifiers and text-heavy variables like movie titles or director names.\n\n```{python}\ncategorical_columns =  movies_cleaned.select_dtypes('object').columns.to_list()\n\ncategorical_columns_remove = ['Title','Release_Date','Distributor','Director']\n\ncategorical_filtered = [col for col in categorical_columns if col not in categorical_columns_remove]\n\n```\n\n\n### Repeated Boxplots: Categorical vs Numerical\n\nWe repeat boxplots using combinations of categorical (rows) and numerical (columns) features. This matrix layout gives a clear visual overview of how numerical values are distributed within each category.\n\n```{python}\nalt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X(alt.repeat('column'),type='quantitative'),\n    alt.Y(alt.repeat('row'),type='nominal'),\n    alt.Size('count()')\n).properties(\n    width=200,\n    height=200\n).repeat(\n    column=numerical_columns,\n    row=categorical_filtered\n)\n```\n\n### Faceted Boxplots\n\nFor more focused analysis, we can facet the boxplots using a specific categorical variable like MPAA_Rating, and repeat the chart by different categorical rows. This lets us keep the numerical axis fixed while comparing how categories vary across different classes (e.g., movie ratings).\n\n\n```{python}\nalt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X('Running_Time_min', type='quantitative'),\n    alt.Y(alt.repeat('row'),type='nominal'),\n    alt.Size('count()'),\n    alt.Tooltip('Title:N')\n).properties(\n    width=100,\n    height=100\n).facet(\n    column='MPAA_Rating'\n).repeat(\n    row=categorical_filtered\n)\n```","srcMarkdownNoYaml":"\n\n# Introduction\n\nExploratory Data Analysis (EDA) is one of the fundamental steps in any data science process. It allows us to **understand the structure**, **detect anomalies**, and **uncover patterns** in the data before modeling.\n\n> *\"Without EDA, you're not doing data science, you're just guessing.\"*\n\nEDA combines statistics, programming, and **visualization** to explore datasets. This report is designed to help you practice these core skills using real-world data.\n\n\n## Dataset\n\nWe will use the **`movies`** dataset from [vega-datasets](https://vega.github.io/vega-datasets/), which includes information about thousands of films such as their ratings, genres, duration, and box office revenue.\n\nLet's load and preview the dataset:\n\n```{python}\nimport pandas as pd\nimport altair as alt\nfrom vega_datasets import data\n\n# Load dataset\nmovies = data.movies()\n\n# Show first rows\nmovies.head()\n```\n\nNow, let’s examine the shape (number of rows and columns) of the dataset:\n\n```{python}\nmovies.shape\n```\n\nThis tells us how many entries (rows) and features (columns) are present in the dataset.\n\n\n## First Steps\n\nBefore diving deeper into the data, it’s useful to explore some key metadata:\n\n- ✅ The **column names** and their **data types**\n- ⚠️ The **presence of missing values**\n- 📊 Summary **statistics** for numeric columns\n\n### Column Names and Data Types\n\nUnderstanding the structure of the dataset helps us know what type of data we're dealing with.\n\n```{python}\nmovies.dtypes\n```\nWe can also use .info() for a more complete summary, including non-null counts:\n\n\n```{python}\n# Overview of the dataset\nmovies.info()\n```\n\n## Missing Values\n\nDetecting and handling missing values is a critical step in any EDA process. Missing data can bias analysis or break downstream models if not handled properly.\n\n- Detect **patterns** in missingness\n- Identify if some columns are almost entirely null\n- Decide whether to **drop** or **impute** certain variables\n\n\n### Percentage of Missing Values per Column\n\nLet’s start by computing the percentage of missing values in each column:\n\n```{python}\nnan_percent = movies.isna().mean() * 100\nnan_percent_sorted = nan_percent.sort_values(ascending=False).round(2)\nnan_percent_sorted\n```\n\n### Reshaping the Data for Visualization\n\nTo visualize missing values with Altair, we need to reshape the data into a long format where each missing value is a row:\n\n```{python}\nmovies_nans = movies.isna().reset_index().melt(\n    id_vars='index',\n    var_name='column',\n    value_name=\"NaN\"\n)\nmovies_nans\n```\n\n### Heatmap of Missing Data\n\nThis heatmap shows where missing values occur across rows and columns. Patterns may indicate:\n\n- Columns with consistently missing values\n- Entire rows with large gaps\n- Correlated missingness between variables\n\nTo avoid limitations in the number of rows rendered by Altair, we disable the max rows warning:\n\n```{python}\nalt.data_transformers.disable_max_rows()\n```\n\nNow we can create the heatmap:\n```{python}\nalt.Chart(movies_nans).mark_rect().encode(\n    alt.X('index:O'),\n    alt.Y('column'),\n    alt.Color('NaN')\n).properties(\n    width=1000\n)\n```\nThis plot can help identify columns or rows with critical data issues.\n\n### Dropping Columns with High Missing Rate\n\nIn many real-world cases, we may decide to remove columns that have too many missing values. Let’s set a threshold of 70%:\n\n```{python}\nthreshold_nan = 70 # in percent\ncols_to_drop = nan_percent[nan_percent>threshold_nan].index\ncols_to_drop\n```\nThese columns have more than 70% missing values and may not be useful for analysis.\n\n\n## Cleaned Dataset\nFinally, we drop the selected columns and inspect the updated dataset:\n\n```{python}\nmovies_cleaned = movies.drop(columns=cols_to_drop)\nmovies_cleaned\n```\n\n\n\n\n# Types of Data Analysis in EDA\n\nUnderstanding the nature of variables and the relationships between them is central to Exploratory Data Analysis (EDA). Depending on the number and type of variables involved, we can classify analysis into three main categories: univariate, bivariate, and multivariate.\n\n@tbl-analysis-types shows how EDA analysis types vary depending on the number and types of variables involved.\n\n> This classification helps guide the selection of appropriate visualization techniques and statistical methods for each case.\n\n::: {.table-caption}\n| **Analysis Type** | **Variable Types**             | **Description**                              | **Examples**                        |\n|-------------------|--------------------------------|----------------------------------------------|-------------------------------------|\n| Univariate        | Categorical                    | One qualitative variable                     | Gender, Product Category            |\n| Univariate        | Quantitative                   | One numerical variable                       | Income, Age, Runtime                |\n| Bivariate         | Categorical – Categorical      | Two qualitative variables                    | Gender vs Nationality               |\n| Bivariate         | Categorical – Quantitative     | One qualitative and one numerical            | Province vs Population              |\n| Bivariate         | Quantitative – Quantitative    | Two numerical variables                      | Age vs Income                       |\n| Multivariate      | 3 or more variables (any mix)  | Combination of categorical and/or numerical  | Age vs Income by Gender, etc.       |\n\nTable: **Types of analysis and variable combinations used in EDA** {#tbl-analysis-types}\n:::\n\n## Univariate Analysis: Quantitative\n\nA univariate analysis focuses on examining a single numeric variable to understand its distribution, shape, central tendency, and spread. One of the most common tools for this is the **histogram**.\n\nIn this case, we’ll explore the distribution of the movie runtime (`Running_Time_min`).\n\n### Basic Histogram\n\nWe start by creating a histogram to visualize the distribution of running times:\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('Running_Time_min',bin=alt.Bin(maxbins=30)),\n    alt.Y('count()')\n).properties(\n    title='Histogram of Movie Runtimes (30 bins)'\n)\n```\nThis chart shows how many movies fall into each time interval (bin). However, histograms can look quite different depending on the number and size of bins used.\n\n### Effect of Bin Size\n\nLet’s compare how the histogram shape changes with different bin sizes:\n```{python}\nhistogram_1 = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('Running_Time_min',bin=alt.Bin(maxbins=8)),\n    alt.Y('count()')\n)\n\nhistogram_2 = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('Running_Time_min',bin=alt.Bin(maxbins=10)),\n    alt.Y('count()')\n)\n\nhistogram_1 | histogram_2\n\n```\n\nEven though both plots use the same data, the choice of bin size changes the visual interpretation. A small number of bins may hide details, while too many bins can make it harder to spot trends.\n\n\n### Density plots, or Kernel Density Estimate (KDE)\n\nDensity plots offer a smoothed alternative to histograms. Instead of using rectangular bins to count data points, they estimate the probability density function by placing bell-shaped curves (kernels) at each observation and summing them.\n\nThis approach helps reduce the visual noise and jaggedness that can occur in histograms and gives a clearer picture of the underlying distribution.\n\n```{python}\nalt.Chart(movies_cleaned).transform_density(\n    'Running_Time_min',\n    as_=['Running_Time_min','density'],\n).mark_area().encode(\n    alt.X('Running_Time_min'),\n    alt.Y('density:Q')\n).properties(\n    title=\"Movies runtime\"\n)\n```\n\n### Grouped Density plot\n\nWe can also compare distributions across groups by splitting the KDE by a **categorical variable** using the groupby parameter. This helps us see how the distribution differs between categories, such as genres.\n\n```{python}\nselection = alt.selection_point(fields=['Major_Genre'], bind='legend')\n\nalt.Chart(movies_cleaned).transform_density(\n    'Running_Time_min',\n    groupby=['Major_Genre'],\n    as_=['Running_Time_min', 'density'],\n).mark_area(opacity=0.5).encode(\n    alt.X('Running_Time_min'),\n    alt.Y('density:Q', stack=None),\n    alt.Color('Major_Genre'),\n    opacity=alt.condition(selection, \n        alt.value(1), \n        alt.value(0.05)\n    )\n).add_params(\n    selection\n).properties(\n    title=\"Movies Runtime by Genre (Interactive Filter)\"\n).interactive()\n```\n\nThe **transparency (opacity=0.5)** allows us to observe overlapping distributions and ensures that small density areas are not completely hidden behind larger ones.\n\nFrom this plot, we can observe, for example, that *Drama* movies have runtimes nearly as long as the longest *Adventure* movies, even though their overall distributions differ.\n\n## Bivariate Analysis: Categorical vs Quantitative\n\nBivariate analysis examines the relationship between two variables. In this case, we focus on one categorical variable (e.g., genre) and one quantitative variable (e.g., revenue), which is a very common scenario in exploratory data analysis.\n\nThis type of analysis is useful to:\n- Compare average or median values across categories.\n- Detect outliers or high-variance groups.\n- Understand distributional differences across categories.\n\nBelow are several effective visualizations for this analysis.\n\n### Basic Barchart\n\nBar charts are effective for comparing aggregated values (like the mean) across different groups. However, they hide the distribution and variation within each group.\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('mean(Worldwide_Gross)'),\n    alt.Y(\"Major_Genre\")\n).properties(\n    title=\"Average Worldwide Gross by Genre\"\n)\n```\nThis bar chart shows the mean Worldwide Gross per genre. It is useful for identifying which genres are more profitable on average, but does not show how spread out the data is.\n\n### Tick Plot\n\nTo visualize individual data points, we use a tick plot. This helps uncover variability within genres and detect outliers.\n\n```{python}\nalt.Chart(movies_cleaned).mark_tick().encode(\n    alt.X('Worldwide_Gross'),\n    alt.Y(\"Major_Genre\"),\n    alt.Tooltip('Title:N')\n).properties(\n    title=\"Individual Gross per Movie by Genre\"\n)\n```\n\n### Heatmaps\n\nHeatmaps can summarize the frequency of data points across both axes (quantitative and categorical) using color intensity. It’s particularly useful for spotting patterns without getting overwhelmed by individual points.\n\n```{python}\nalt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X('Worldwide_Gross',bin=alt.Bin(maxbins=100)),\n    alt.Y(\"Major_Genre\"),\n    alt.Color('count()'),\n    alt.Tooltip('count()')\n).properties(\n    title=\"Heatmap of Movie Counts by Gross and Genre\"\n)\n```\nThis heatmap shows how frequently movies from each genre fall into different revenue ranges.\n\n\n\n### Boxplot\n\nBoxplots are useful for comparing distributions across categories and identifying outliers. Boxplots summarize a distribution using five statistics:\n\n- Median (Q2)\n- First Quartile (Q1)\n- Third Quartile (Q3)\n- Lower Whisker (Q1 - 1.5 × IQR)\n- Upper Whisker (Q3 + 1.5 × IQR)\n\n```{python}\nalt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X('Worldwide_Gross'),\n    alt.Y(\"Major_Genre\")\n).properties(\n    title=\"Boxplot of Worldwide Gross by Genre\"\n)\n```\n\n\n### Side-by-side: Boxplot and Bar Chart\n\nTo contrast aggregated values (bar chart) with the full distribution (boxplot), we can display them together:\n\n```{python}\nbar = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('mean(Worldwide_Gross)'),\n    alt.Y(\"Major_Genre\")\n)\n\nbox = alt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X('mean(Worldwide_Gross)'),\n    alt.Y(\"Major_Genre\")\n)\n\nbox | bar\n```\nThis comparison reveals whether the mean is a good representative of the genre, or whether the data is skewed or contains outliers that affect the average\n\n## Bivariate Analysis: Quantitative vs Quantitative\n\nWhen analyzing two quantitative (numerical) variables simultaneously, we aim to discover possible relationships, trends, or correlations. This type of bivariate analysis can reveal whether increases in one variable are associated with increases or decreases in another (positive or negative correlation), or if there’s no relationship at all. The most common and intuitive visualization for this is the **scatterplot**.\n\n### Scatterplots\n\nScatter plots are effective visualizations for exploring **two-dimensional distributions**, allowing us to identify patterns, trends, clusters, or outliers.\n\nLet’s start by visualizing how movies are rated across two popular online platforms:\n\n- [IMDb](https://www.imdb.com/)  \n- [Rotten Tomatoes](https://www.rottentomatoes.com)\n\nAre movies rated similarly on different platforms?\n\n\n```{python}\nalt.Chart(movies_cleaned).mark_point().encode(\n    alt.X('IMDB_Rating'),\n    alt.Y('Rotten_Tomatoes_Rating')\n).properties(\n    title=\"IMDB vs Rotten Tomatoes Ratings\"\n)\n```\n\n### Scatterplot Saturation\n\nScatterplots can become saturated when too many points overlap in a small area of the chart, making it difficult to distinguish dense regions from sparse ones. For example, when plotting financial variables like production budget versus worldwide gross:\n\n\n```{python}\nsaturated = alt.Chart(movies_cleaned).mark_point().encode(\n    alt.X('Production_Budget'),\n    alt.Y('Worldwide_Gross')\n).properties(\n    title=\"Saturated Scatterplot: Budget vs Gross\"\n)\nsaturated\n```\n\n### Using Binned Heatmap to Reduce Saturation\nTo address saturation, we can **bin** both variables and use a heatmap where the color intensity represents the number of movies that fall into each rectangular region of the grid. This makes dense areas more interpretable\n\n```{python}\nheatmap_scatter = alt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X('Production_Budget', bin=alt.Bin(maxbins=60)),\n    alt.Y('Worldwide_Gross', bin=alt.Bin(maxbins=60)),\n    alt.Color('count()'),\n    alt.Tooltip('count()')\n).properties(\n    title=\"Binned Heatmap: Budget vs Gross\"\n)\nheatmap_scatter\n```\n\n### Side-by-side Comparison\n\nCompare the raw scatterplot with the heatmap representation:\n\n\n```{python}\nsaturated | heatmap_scatter\n```\n\n\n## Bivariate Analysis: Categorical vs Categorical\n\n\nWhen working with **two categorical variables**, bivariate analysis helps us understand how categories from one variable relate or are distributed across the other. For example, we might want to know how different **movie genres** are rated according to the **MPAA rating system**. Visualization techniques like grouped bar charts and faceted plots can reveal patterns, associations, or class imbalances.\n\n### Basic Faceted Bar Chart\n\nWe begin by exploring how movies are rated (MPAA_Rating) across different genres (Major_Genre). A faceted bar chart allows us to visualize this relationship by plotting a bar chart **per genre**, helping to identify genre-specific rating distributions.\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre'\n)\n```\n\n### Vertical Faceting for Alignment\n\nFaceting horizontally can make comparisons across genres harder when the x-axis is misaligned. By specifying columns=1, we lay out the facets vertically, making it easier to compare counts across genres.\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre',\n    columns=1\n)\n```\n\n### Dependent vs Independent Axis Scaling\n\nBy default, facet plots share the same x-axis scale (dependent scale), which allows for easier comparison across panels. However, when the number of observations varies greatly between genres, this shared scale can compress some charts.\n\nWe can instead use independent x-axis scaling for each facet. This highlights the relative distribution within each genre.\n\n```{python}\nshared_scale = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre',\n    columns=4\n)\n\nindependent_scale = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre',\n    columns=4\n).resolve_scale(x='independent')\n\nshared_scale | independent_scale\n```\n\nThe left panel (shared scale) makes absolute comparisons between genres, while the right panel (independent scale) makes within-genre comparisons more readable.\n\n\n### Heatmaps\n\nHeatmaps are effective for visualizing the relationship between two **categorical variables** when the goal is to display **counts or frequency** of occurrences. They map **the number of observations** to **color**, providing an intuitive view of which category pairs are most or least common.\n\nWe can enhance this basic representation by also using **marker size**, combining both **color intensity** and **circle area** to represent counts more effectively. This dual encoding can improve interpretation, especially when printed in grayscale or when there are subtle color differences.\n\n\n\n```{python}\nheatmap_color = alt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X('MPAA_Rating'),\n    alt.Y('Major_Genre', sort='color'),\n    alt.Color('count()')\n).properties(\n    title=\"Heatmap with Color (Count of Movies)\"\n)\n\nheatmap_size = alt.Chart(movies_cleaned).mark_circle().encode(\n    alt.X('MPAA_Rating'),\n    alt.Y('Major_Genre', sort='color'),\n    alt.Color('count()'),\n    alt.Size('count()')\n).properties(\n    title=\"Heatmap with Color + Size (Count of Movies)\"\n)\n\nheatmap_color | heatmap_size\n```\n\n\n## Multivariate Analysis\n\n\nMultivariate analysis helps us understand the interactions and relationships among multiple variables simultaneously. In the context of numerical features, it is useful to explore pairwise distributions, correlations, and detect potential clusters or anomalies.\n\nWhen the number of variables is large, **repeated charts** such as histograms or scatter plot matrices help us summarize patterns efficiently and consistently across all numerical dimensions.\n\n### Repeated Histograms for Numerical Columns\n\nWe first identify and isolate all numerical columns from the dataset. Then we repeat a histogram for each of these columns to understand the individual distributions. This overview is helpful to detect skewness, outliers, or binning decisions that affect how data is grouped visually.\n\n\n```{python}\n# Select only numerical columns\nnumerical_columns = movies_cleaned.select_dtypes('number').columns.tolist()\n```\n\n```{python}\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X(alt.repeat(),type='quantitative',bin=alt.Bin(maxbins=30)),\n    alt.Y('count()')\n).properties(\n    width=150,\n    height=150\n).repeat(\n    numerical_columns,\n    columns=4\n)\n\n```\n\n### Scatter Plot Matrix (Pairplot)\n\nA scatter plot matrix shows the pairwise relationships between all numerical variables. This is a common exploratory tool to detect:\n\n- Correlations between variables\n- Outliers or clusters\n- Relationships useful for prediction models (e.g., to predict rating or budget)\n\nWe focus especially on the plots below the diagonal, as they are not duplicated.\n```{python}\nalt.Chart(movies_cleaned).mark_point().encode(\n    alt.X(alt.repeat('column'),type='quantitative'),\n    alt.Y(alt.repeat('row'),type='quantitative'),\n    alt.Tooltip('Title:N')\n).properties(\n    width=100,\n    height=100\n).repeat(\n    column=numerical_columns,\n    row=numerical_columns\n)\n```\n\n### Heatmap Matrix\nWhen scatter plots become too saturated (many overlapping points), heatmaps offer a better alternative by binning the numeric values and encoding the **count** in **color intensity**.\n\n```{python}\nalt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X(alt.repeat('column'),type='quantitative',bin=alt.Bin(maxbins=30)),\n    alt.Y(alt.repeat('row'),type='quantitative',bin=alt.Bin(maxbins=30)),\n    alt.Color('count()'),\n    alt.Tooltip('count()')\n).properties(\n    width=100,\n    height=100\n).repeat(\n    column=numerical_columns,\n    row=numerical_columns\n).resolve_scale(\n    color='independent'\n)\n```\n\nTo gain deeper insights into the dataset, it's important to analyze how **numerical variables** behave across **different categories**. This type of multivariate analysis allows us to:\n\n- Compare distributions across categories\n- Detect outliers within categories\n- Observe central tendency (median, quartiles) and spread (range, IQR)\n\nBoxplots are particularly effective for this purpose. In the following visualizations, we explore these relationships by **repeating plots across combinations** of categorical and numerical features.\n\n### Filter Categorical Columns\n\nFirst, we select the relevant categorical columns, excluding identifiers and text-heavy variables like movie titles or director names.\n\n```{python}\ncategorical_columns =  movies_cleaned.select_dtypes('object').columns.to_list()\n\ncategorical_columns_remove = ['Title','Release_Date','Distributor','Director']\n\ncategorical_filtered = [col for col in categorical_columns if col not in categorical_columns_remove]\n\n```\n\n\n### Repeated Boxplots: Categorical vs Numerical\n\nWe repeat boxplots using combinations of categorical (rows) and numerical (columns) features. This matrix layout gives a clear visual overview of how numerical values are distributed within each category.\n\n```{python}\nalt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X(alt.repeat('column'),type='quantitative'),\n    alt.Y(alt.repeat('row'),type='nominal'),\n    alt.Size('count()')\n).properties(\n    width=200,\n    height=200\n).repeat(\n    column=numerical_columns,\n    row=categorical_filtered\n)\n```\n\n### Faceted Boxplots\n\nFor more focused analysis, we can facet the boxplots using a specific categorical variable like MPAA_Rating, and repeat the chart by different categorical rows. This lets us keep the numerical axis fixed while comparing how categories vary across different classes (e.g., movie ratings).\n\n\n```{python}\nalt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X('Running_Time_min', type='quantitative'),\n    alt.Y(alt.repeat('row'),type='nominal'),\n    alt.Size('count()'),\n    alt.Tooltip('Title:N')\n).properties(\n    width=100,\n    height=100\n).facet(\n    column='MPAA_Rating'\n).repeat(\n    row=categorical_filtered\n)\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"embed-resources":true,"number-sections":true,"output-file":"eda.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.24","theme":"cosmo","title":"Exploratory Data Analysis (EDA)"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}